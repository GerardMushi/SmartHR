# -*- coding: utf-8 -*-
"""modules_absenteeism_final

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wRT7cenVAglFGSSTOd2uPkvXVj1SVIx5
"""

# modules/modules_absenteeism_final.py
from __future__ import annotations
from pathlib import Path
import calendar
import numpy as np
import pandas as pd

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import (
    accuracy_score, f1_score, roc_auc_score, average_precision_score, confusion_matrix
)
from sklearn.inspection import permutation_importance


# ----------------------------
# Reason code -> human name (UCI Absenteeism)
# ----------------------------
REASON_MAP_DEFAULT = {
    0:  "Unknown",
    1:  "Infectious & parasitic",
    2:  "Neoplasms",
    3:  "Blood/immune disorders",
    4:  "Endocrine/metabolic",
    5:  "Mental & behavioural",
    6:  "Nervous system",
    7:  "Eye/adnexa",
    8:  "Ear/mastoid",
    9:  "Circulatory system",
    10: "Respiratory system",
    11: "Digestive system",
    12: "Skin/subcutaneous",
    13: "Musculoskeletal system",
    14: "Genitourinary system",
    15: "Pregnancy/childbirth",
    16: "Perinatal conditions",
    17: "Congenital anomalies",
    18: "Symptoms/abnormal findings",
    19: "Injury/poisoning",
    20: "External causes",
    21: "Health services contact",
    22: "Patient follow-up",
    23: "Medical consultation",
    24: "Blood donation",
    25: "Lab exam",
    26: "Unjustified absence",
    27: "Physiotherapy",
    28: "Dental consultation",
}

_MONTH_NAME = {i: calendar.month_name[i] for i in range(0, 13)}
_MONTH_NAME[0] = "Unknown"  # dataset sometimes uses 0
_WEEKDAY_NAME = {2: "Mon", 3: "Tue", 4: "Wed", 5: "Thu", 6: "Fri", 7: "Sat", 1: "Sun", 0: "Sun"}
_SEASON_FROM_UCI = {1: "Summer", 2: "Autumn", 3: "Winter", 4: "Spring"}

def _season_from_month(m: int) -> str:
    if m in (12, 1, 2):  return "Winter"
    if m in (3, 4, 5):   return "Spring"
    if m in (6, 7, 8):   return "Summer"
    if m in (9, 10, 11): return "Autumn"
    return "Unknown"


# ----------------------------
# Data loading / cleaning
# ----------------------------
def load_dataset(path: str | Path | None = None) -> pd.DataFrame:
    """Load UCI Absenteeism CSV (comma or semicolon auto-detected)."""
    if path is None:
        path = Path(__file__).resolve().parents[1] / "data" / "Absenteeism_at_work.csv"
    return pd.read_csv(path, sep=None, engine="python")

def clean_columns(df: pd.DataFrame) -> pd.DataFrame:
    out = df.copy()
    out.columns = out.columns.str.strip()
    return out


# ----------------------------
# Event-level labeling (names instead of numbers)
# ----------------------------
def label_event_level(df: pd.DataFrame) -> pd.DataFrame:
    """Add MonthName, WeekdayName, SeasonName, ReasonLabel to event-level df."""
    df = clean_columns(df)

    # Month
    if "Month of absence" in df.columns:
        df["MonthName"] = pd.to_numeric(df["Month of absence"], errors="coerce").map(_MONTH_NAME).fillna("Unknown")
    else:
        df["MonthName"] = "Unknown"

    # Weekday  (FIXED: _WEEKDAY_NAME)
    if "Day of the week" in df.columns:
        df["WeekdayName"] = pd.to_numeric(df["Day of the week"], errors="coerce").map(_WEEKDAY_NAME).fillna("Unknown")
    else:
        df["WeekdayName"] = "Unknown"

    # Season (prefer month; fallback to UCI 'Seasons')
    if "Month of absence" in df.columns:
        months = pd.to_numeric(df["Month of absence"], errors="coerce").fillna(0).astype(int)
        df["SeasonName"] = months.map(_season_from_month)
    elif "Seasons" in df.columns:
        df["SeasonName"] = pd.to_numeric(df["Seasons"], errors="coerce").map(_SEASON_FROM_UCI).fillna("Unknown")
    else:
        df["SeasonName"] = "Unknown"

    # Reason
    if "Reason for absence" in df.columns:
        codes = pd.to_numeric(df["Reason for absence"], errors="coerce").astype("Int64")
        lbl = codes.map(REASON_MAP_DEFAULT).astype("object")
        lbl[codes.isna()] = "Unknown"
        lbl[pd.isna(lbl)] = codes[pd.isna(lbl)].apply(lambda x: f"Reason {int(x)}" if pd.notna(x) else "Unknown")
        df["ReasonLabel"] = lbl
    else:
        df["ReasonLabel"] = "Unknown"

    return df


def filter_by_seasons(df: pd.DataFrame, seasons: list[str]) -> pd.DataFrame:
    if "SeasonName" not in df.columns:
        df = label_event_level(df)
    if not seasons:
        return df
    return df[df["SeasonName"].isin(seasons)].copy()


# ----------------------------
# Employee-level aggregation
# ----------------------------
def aggregate_employee_level(df: pd.DataFrame) -> pd.DataFrame:
    df = clean_columns(df)

    if "ID" not in df.columns:
        df = df.copy()
        df.insert(0, "ID", np.arange(1, len(df) + 1))

    if "Absenteeism time in hours" not in df.columns:
        raise ValueError("Column 'Absenteeism time in hours' not found.")

    # Ensure Request_duration on event-level
    if "Request_duration" not in df.columns:
        def _dur(h):
            if h < 8: return "Less than 1 day"
            if h == 8: return "1 day"
            if h <= 24: return "1–3 days"
            return "More than 3 days"
        df["Request_duration"] = df["Absenteeism time in hours"].apply(_dur)

    g = df.groupby("ID", as_index=True)
    agg = pd.DataFrame({
        "total_hours": g["Absenteeism time in hours"].sum(),
        "n_events":    g["Absenteeism time in hours"].size(),
        "avg_hours":   g["Absenteeism time in hours"].mean(),
        "std_hours":   g["Absenteeism time in hours"].std().fillna(0.0),
    })

    # Reason counts
    if "Reason for absence" in df.columns:
        reason_counts = (
            df.pivot_table(index="ID", columns="Reason for absence",
                           values="Absenteeism time in hours",
                           aggfunc="count", fill_value=0)
            .add_prefix("reason_")
        )
        agg = agg.join(reason_counts, how="left")

    # Duration counts & rates
    dur_counts = (
        df.pivot_table(index="ID", columns="Request_duration",
                       values="Absenteeism time in hours",
                       aggfunc="count", fill_value=0)
        .reindex(columns=["Less than 1 day","1 day","1–3 days","More than 3 days"], fill_value=0)
    )
    agg = agg.join(dur_counts)
    agg["pct_short"] = (agg["Less than 1 day"] + agg["1 day"]) / agg["n_events"].replace(0, np.nan)
    agg["pct_long"]  = agg["More than 3 days"] / agg["n_events"].replace(0, np.nan)
    agg[["pct_short","pct_long"]] = agg[["pct_short","pct_long"]].fillna(0)

    return agg.reset_index()


def make_labels(agg_df: pd.DataFrame,
                quantile: float = 0.80,
                abs_threshold: float | None = None) -> tuple[pd.Series, float]:
    tgt = agg_df["total_hours"]
    thr = float(abs_threshold) if (abs_threshold is not None and abs_threshold > 0) else float(tgt.quantile(quantile))
    y = (tgt >= thr).astype(int)
    return y, thr


# ----------------------------
# Modeling
# ----------------------------
def train_and_eval(agg_df: pd.DataFrame,
                   quantile: float = 0.80,
                   abs_threshold: float | None = None,
                   features_include: list[str] | None = None,
                   random_state: int = 42):
    """
    Train RandomForest (High vs Not-High) on aggregated data.
    Returns: metrics, cm_df, imp_df, thr, model, X_test, y_test, y_proba, y_pred, test_ids
    """
    y, thr = make_labels(agg_df, quantile=quantile, abs_threshold=abs_threshold)

    X = agg_df.drop(columns=["ID", "total_hours"], errors="ignore").copy()
    if features_include:
        keep = [f for f in features_include if f in X.columns]
        if keep:
            X = X[keep]

    for c in X.columns:
        if not np.issubdtype(X[c].dtype, np.number):
            X[c] = X[c].astype("category").cat.codes

    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.25, stratify=y, random_state=random_state
    )
    test_ids = agg_df.loc[X_test.index, "ID"].values

    model = RandomForestClassifier(
        n_estimators=400, min_samples_split=5, min_samples_leaf=2,
        random_state=random_state, n_jobs=-1
    )
    model.fit(X_train, y_train)

    y_pred  = model.predict(X_test)
    y_proba = model.predict_proba(X_test)[:, 1]

    metrics = {
        "accuracy": float(accuracy_score(y_test, y_pred)),
        "f1":       float(f1_score(y_test, y_pred)),
        "roc_auc":  float(roc_auc_score(y_test, y_proba)),
        "pr_auc":   float(average_precision_score(y_test, y_proba)),
    }
    cm = confusion_matrix(y_test, y_pred, labels=[0, 1])
    cm_df = pd.DataFrame(cm, index=["true_NotHigh","true_High"],
                             columns=["pred_NotHigh","pred_High"])

    pi = permutation_importance(model, X_test, y_test, n_repeats=20, random_state=random_state)
    imp_df = (pd.DataFrame({"feature": X.columns, "importance": pi.importances_mean})
                .sort_values("importance", ascending=False)
                .reset_index(drop=True))

    return metrics, cm_df, imp_df, thr, model, X_test, y_test, y_proba, y_pred, test_ids

